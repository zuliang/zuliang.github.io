{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Algorithm/","text":"Algorithm quick sort reference import bigarray def quicksort(a, lo, hi): idx = partition(a, lo, hi) if idx lo: quicksort(a, lo, idx-1) if idx hi: quicksort(a, idx+1, hi) def partition(a, lo, hi): idx = lo for i in range(lo, hi): if a[i] a[hi]: a[i], a[idx] = a[idx], a[i] idx += 1 a[hi], a[idx] = a[idx], a[hi] return idx def find_k(a, lo, hi, k): idx = partition(a, lo, hi) if idx k: find_k(a, idx+1, hi, k) elif idx k: find_k(a, lo, idx-1, k) elif idx == k: print a[idx] if __name__ == '__main__': a = [6,5,4,0,2,1,3] quicksort(a, 0, len(a)-1) print a # find_k(a, 0, len(a)-1, 6) # print a[6] bfs import Queue from tree import build_tree def prettify_bfs(node): q = Queue.Queue() q.put(node) while not q.empty(): node = q.get() print node.depth * -- + node.val for child in node.children: child.depth = node.depth + 1 q.put(child) def bfs(node): q = Queue.Queue() q.put(node) while not q.empty(): node = q.get() print node.val for child in node.children: q.put(child) def bfs_recursive(node): q = Queue.Queue() q.put(node) def traverse(q): if q.empty(): return node = q.get() print node.val for child in node.children: q.put(child) traverse(q) traverse(q) if __name__ == '__main__': root = build_tree() # bfs(root) prettify_bfs(root) dfs import Queue from tree import buil_tree def prettify_dfs(node, depth): print depth * -- + node.val for child in node.children: prettify_dfs(child, depth + 1) def dfs_recursive(node): print node.val for child in node.children: dfs_recursive(child) def dfs(node): stack = Queue.LifoQueue() stack.put(node) while not stack.empty(): node = stack.get() print node.depth * -- + node.val for child in node.children: child.depth = node.depth + 1 stack.put(child) if __name__ == '__main__': root = buil_tree() dfs(root)","title":"Algorithm"},{"location":"Algorithm/#algorithm","text":"","title":"Algorithm"},{"location":"Algorithm/#quick-sort-reference","text":"import bigarray def quicksort(a, lo, hi): idx = partition(a, lo, hi) if idx lo: quicksort(a, lo, idx-1) if idx hi: quicksort(a, idx+1, hi) def partition(a, lo, hi): idx = lo for i in range(lo, hi): if a[i] a[hi]: a[i], a[idx] = a[idx], a[i] idx += 1 a[hi], a[idx] = a[idx], a[hi] return idx def find_k(a, lo, hi, k): idx = partition(a, lo, hi) if idx k: find_k(a, idx+1, hi, k) elif idx k: find_k(a, lo, idx-1, k) elif idx == k: print a[idx] if __name__ == '__main__': a = [6,5,4,0,2,1,3] quicksort(a, 0, len(a)-1) print a # find_k(a, 0, len(a)-1, 6) # print a[6]","title":"quick sort reference"},{"location":"Algorithm/#bfs","text":"import Queue from tree import build_tree def prettify_bfs(node): q = Queue.Queue() q.put(node) while not q.empty(): node = q.get() print node.depth * -- + node.val for child in node.children: child.depth = node.depth + 1 q.put(child) def bfs(node): q = Queue.Queue() q.put(node) while not q.empty(): node = q.get() print node.val for child in node.children: q.put(child) def bfs_recursive(node): q = Queue.Queue() q.put(node) def traverse(q): if q.empty(): return node = q.get() print node.val for child in node.children: q.put(child) traverse(q) traverse(q) if __name__ == '__main__': root = build_tree() # bfs(root) prettify_bfs(root)","title":"bfs"},{"location":"Algorithm/#dfs","text":"import Queue from tree import buil_tree def prettify_dfs(node, depth): print depth * -- + node.val for child in node.children: prettify_dfs(child, depth + 1) def dfs_recursive(node): print node.val for child in node.children: dfs_recursive(child) def dfs(node): stack = Queue.LifoQueue() stack.put(node) while not stack.empty(): node = stack.get() print node.depth * -- + node.val for child in node.children: child.depth = node.depth + 1 stack.put(child) if __name__ == '__main__': root = buil_tree() dfs(root)","title":"dfs"},{"location":"pow/","text":"power algorithm \u5206\u6cbb\u5904\u7406 x\u548cn\u662f\u6574\u6570\uff0c\u4ee5\u4e0b\u7b97\u6cd5\u590d\u6742\u5ea6\u4e3aO(lgn),\u5c06\u9636\u4e58\u4e00\u5206\u4e3a\u4e8c\u9012\u5f52\uff0c\u9700\u8981\u6ce8\u610f\uff1a 1. n\u7684\u5947\u5076\u60c5\u51b5 2. n\u4e3a\u8d1f\u6570\u8fd9\u4e2a\u5751 def pow(x, n): if n == 0: return 1 if n 0: return 1.0 / pow(x, -n) if n % 2: return x * pow(x, n-1) else: return pow(x*x, n/2) def pow_nonrevcursive(x, n): if n 0: x = 1.0 / x n = -n powe = 1 while n: if n 1: powe *= x x *= x n = 1 return powe","title":"pow(x,n)"},{"location":"pow/#power-algorithm","text":"","title":"power algorithm"},{"location":"pow/#_1","text":"x\u548cn\u662f\u6574\u6570\uff0c\u4ee5\u4e0b\u7b97\u6cd5\u590d\u6742\u5ea6\u4e3aO(lgn),\u5c06\u9636\u4e58\u4e00\u5206\u4e3a\u4e8c\u9012\u5f52\uff0c\u9700\u8981\u6ce8\u610f\uff1a 1. n\u7684\u5947\u5076\u60c5\u51b5 2. n\u4e3a\u8d1f\u6570\u8fd9\u4e2a\u5751 def pow(x, n): if n == 0: return 1 if n 0: return 1.0 / pow(x, -n) if n % 2: return x * pow(x, n-1) else: return pow(x*x, n/2) def pow_nonrevcursive(x, n): if n 0: x = 1.0 / x n = -n powe = 1 while n: if n 1: powe *= x x *= x n = 1 return powe","title":"\u5206\u6cbb\u5904\u7406"}]}